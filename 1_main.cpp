/************************************************************
URL
	http://tercel-tech.hatenablog.com/entry/2012/11/03/003302

即死sample
	C++では、コピーコンストラクタや代入演算子を適切に定義しないとメモリが二重解放されてしまう危険性がある。
	『C++のためのAPIデザイン』のp.211には以下のように書かれています。
		値オブジェクトを作成するときは「ビッグスリー」原則に従うことが重要である。ビッグスリー原則とはマーシャル・クラインが1990年代初頭に提案した原則で、
		「デストラクタ、コピーコンストラクタ、代入演算子の3つのメンバ関数は常に共存する必要がある」というものだ。

	今回の例では、
	add()でcopy constructorが走るが、class AのmXはpointerで、これがcopyされてしまう。
	つまり、新たにnew intされるのでなく、指し示す先が置きかわる。
	
	この後、add()を抜ける時にadd()内localのaがReleaseされる。
	main()に戻って、
		*( gA[ 0 ].mX ) = 6;
	は、すでに解放された先にaccessしている。
	
	さらに、program終了時にgAがReleaseされるが、
	すでに解放済みのメモリを解放にいくので、Crash.
************************************************************/
#include <stdio.h>
#include <vector>
using namespace std;

/************************************************************
************************************************************/
class A {
public:
	A() { mX = new int; }
	~A() { delete mX; }
	int* mX;
};

vector< A > gA;

void add() {
	A a;
	gA.push_back( a );
}

/************************************************************
************************************************************/

/******************************
******************************/
int main() {
	add();
	*( gA[ 0 ].mX ) = 6;
	
	return 0;
}

